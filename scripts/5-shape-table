#!/usr/bin/env python

from matplotlib import pyplot as plt
import upcycle as U
import numpy as np
import os
import itertools
import functools

@functools.singledispatch
def op_short_str(op): return '' #raise NotImplementedError()

def short_dtype(dtype): return ''
    # return 'I8' if dtype == U.Dtype.I8 else 'F16'

@op_short_str.register
def _(op : U.ops.Conv):
    si = f'{op.si[0]}$^{op.d}$'
    return f'I{short_dtype(op.dtype)} C{len(op.si)}D({op.n}x {si} {op.c}-\\textgreater{{}}{op.k} f={op.sf[0]} s{op.stride})'

@op_short_str.register
def _(op : U.ops.Matmul):
    layout = U.ops.Matmul.layout_str(op.tr_a, op.tr_b)
    return f'I{short_dtype(op.dtype)} Matmul[{layout}]({op.m}x{op.n}x{op.k})'

@op_short_str.register
def _(op : U.ops.Linear):
    layout = U.ops.Linear.layout_str(op.tr_a, op.tr_b)
    return f'I{short_dtype(op.dtype)} Linear[{layout}]({op.m}x{op.n}x{op.k})'

@op_short_str.register
def _(op : U.ops.LstmCell):
    layout = U.ops.Linear.layout_str(op.mm.tr_a, op.mm.tr_b)
    return f'I{short_dtype(op.dtype)} Lstm[{layout}]({op.mm.m}x{op.mm.n}x{op.mm.k})'



@op_short_str.register
def _(op : U.apps.TrainOp):
    return 'T' + op_short_str(op.fwd_op)[1:]



apps : dict[str, U.apps.Trace] = {
    'resnet50-infer-online':  U.apps.mlperf_v1_apps['resnet50'].default_infer_online(),
    'resnet50-infer-offline': U.apps.mlperf_v1_apps['resnet50'].default_infer_offline(),
    'resnet50-train-small':   U.apps.mlperf_v1_apps['resnet50'].default_train_small(),
    'resnet50-train-large':   U.apps.mlperf_v1_apps['resnet50'].default_train_large(),

    'ssdrn34-infer-online':  U.apps.mlperf_v1_apps['ssdrn34-1200'].default_infer_online(),
    'ssdrn34-infer-offline': U.apps.mlperf_v1_apps['ssdrn34-1200'].default_infer_offline(),
    'ssdrn34-train-small':   U.apps.mlperf_v1_apps['ssdrn34-300'].default_train_small(),
    'ssdrn34-train-large':   U.apps.mlperf_v1_apps['ssdrn34-300'].default_train_large(),

    'unet-infer-online':  U.apps.mlperf_v1_apps['unet'].default_infer_online(),
    'unet-infer-offline': U.apps.mlperf_v1_apps['unet'].default_infer_offline(),
    'unet-train-small':   U.apps.mlperf_v1_apps['unet'].default_train_small(),
    'unet-train-large':   U.apps.mlperf_v1_apps['unet'].default_train_large(),

    'bert-infer-online':  U.apps.mlperf_v1_apps['bert-large-squad'].default_infer_online(),
    'bert-infer-offline': U.apps.mlperf_v1_apps['bert-large-squad'].default_infer_offline(),
    'bert-train-small':   U.apps.mlperf_v1_apps['bert-large-pretrain'].default_train_small(),
    'bert-train-large':   U.apps.mlperf_v1_apps['bert-large-pretrain'].default_train_large(),

    'rnnt-infer-online':  U.apps.mlperf_v1_apps['rnnt'].default_infer_online(),
    'rnnt-infer-offline': U.apps.mlperf_v1_apps['rnnt'].default_infer_offline(),
    'rnnt-train-small':   U.apps.mlperf_v1_apps['rnnt'].default_train_small(),
    'rnnt-train-large':   U.apps.mlperf_v1_apps['rnnt'].default_train_large(),
}

infer_online = {appname: app for appname, app in apps.items() if appname.endswith('-infer-online')}
infer_offline = {appname: app for appname, app in apps.items() if appname.endswith('-infer-offline')}
train_small = {appname: app for appname, app in apps.items() if appname.endswith('-train-small')}
train_large = {appname: app for appname, app in apps.items() if appname.endswith('-train-large')}

appnames = ['resnet50', 'ssdrn34', 'unet', 'bert', 'rnnt']

arch =  U.arch.arch_factory('hier', dict(
    vbits=512,
    geom=U.arch.ntiles_to_geom(2048),
    compute_scale=[0.5, 1, 2, 10, 100, 0],
    noc_scale=[0.5, 1, 2, 10, 100, 0]))

arch_notp =  U.arch.arch_factory('hier', dict(
    vbits=512,
    tpeng=False,
    geom=U.arch.ntiles_to_geom(2048),
    compute_scale=[0.5, 1, 2, 10, 100, 0],
    noc_scale=[0.5, 1, 2, 10, 100, 0]))

db = U.simdb.SimDb(arch)
db_notp = U.simdb.SimDb(arch_notp)
nv = U.nvdb.NvDb()

ti = 0
tags = [
    # Resnet50
    ['SS', 'LC'],
    ['LS', 'SC'],
    ['SS', 'Larger spatial => A100 better'],
    ['F1', 'LC', 'A-'],
    ['SS', 'BP'],

    ['DW', 'SS'],
    ['DW', 'LS', 'SC'],
    ['DW', 'LS', 'SC'],
    ['DW', 'F1', 'LC'],
    ['DW', 'F1', 'LC', 'Flipped CK better'],

    # SSDRN34
    ['LS', 'LC', 'GP'],
    ['LS', 'LC'],
    ['LS'],
    ['LS', 'LC'],
    ['S2'],

    ['DW', 'SS', 'LC'],
    ['DW', 'SS', 'LC'],
    ['DW', 'SS', 'LC'],
    ['DW', 'SS', 'LC'],
    ['DW', 'SS', 'LC'],

    # UNET
    ['BP', 'LS', 'SC'],
    ['BP', 'LS', 'SC'],
    ['BP', 'LS', 'SC', 'Larger KxC is better'],
    ['BP', 'LS', 'LC'],
    ['BP', 'LS', 'LC', 'Large KxC compensates'],

    ['DW', 'LS', 'SC'],
    ['DW', 'LS', 'SC'],
    ['DW', 'LS', 'SC'],
    ['DW', 'LS', 'LC'],
    ['DW', 'LS', 'LC'],

    # BERT
    ['LM', 'LN', 'LK'],
    ['LM', 'LN', 'LK', '4x N => TC way better'],
    ['LM', 'LN', 'LK'],
    ['LL', 'SM', 'SN'],
    ['LL', 'SM', 'SN'],

    ['TP', 'LM', 'LN', 'LK'],
    ['TP', 'LM', 'LN', 'LK'],
    ['TP', 'LM', 'LN', 'LK'],
    ['TP', 'LL', 'SM', 'SN'],
    ['TP', 'LL', 'SM', 'SN'],

    # RNNT
    ['EW', 'LN', 'LK'],
    ['EW', 'LN', 'LK'],
    ['EW', 'LN', 'LK'],
    ['EW', 'SK'],
    ['EW', 'BP'],

    ['TP', 'EW', 'LN', 'LK'],
    ['TP', 'EW', 'LN', 'LK'],
    ['TP', 'EW', 'LN', 'LK'],
    ['TP', 'EW', 'SK'],
    ['TP', 'EW', ],
]

mask = [
    # Resnet50
    True,
    True,
    True,
    True,
    True,

    True,
    True,
    True,
    True,
    True,

    # SSDRN34
    True,
    True,
    True,
    True,
    True,

    True,
    True,
    True,
    True,
    True,

    # UNET
    True,
    True,
    True,
    True,
    True,

    True,
    True,
    True,
    True,
    True,

    # BERT
    True,
    True,
    True,
    True,
    True,

    True,
    True,
    True,
    True,
    True,

    # RNNT
    True,
    True,
    True,
    True,
    True,

    True,
    True,
    True,
    True,
    True,
]

def process_tag(tag):
    if len(tag) == 2:
        return f'\\tag{{{tag}}}'
    else:
        return tag

ni = 1

def analyze_app(db : U.simdb.SimDb, app : U.apps.Trace):
    global ti
    global ni
    arch_ext = U.simdb.ArchExtConfig(2.4e9, 900 * 2**30, 1.0, 1.0, 1.0)
    arch_ext_ex = U.simdb.ArchExtConfig(2.4e9, 900 * 2**30, 2.0, 1.0, 1.0)
    arch_ext_comm = U.simdb.ArchExtConfig(2.4e9, 900 * 2**30, 1.0, 2.0, 1.0)
    arch_ext_mem = U.simdb.ArchExtConfig(2.4e9, 900 * 2**30, 1.0, 1.0, 2.0)

    total_lat = db.lat(app, arch_ext)

    ex2_speedup = total_lat / db.lat(app, arch_ext_ex)
    comm2_speedup = total_lat / db.lat(app, arch_ext_comm)
    mem2_speedup = total_lat / db.lat(app, arch_ext_mem)
    speedups = [ex2_speedup, comm2_speedup, mem2_speedup]
    best_speedup = max(ex2_speedup, comm2_speedup, mem2_speedup)

    if best_speedup == ex2_speedup:
        sens = 'ex'
    elif best_speedup == comm2_speedup:
        sens = 'comm'
    elif best_speedup == mem2_speedup:
        sens = 'mem'

    unique_ops = list(app.unique_ops)
    counts = [app.count(op) for op in unique_ops]
    contrib = [counts[i] * unique_ops[i].flops / app.flops for i in range(len(unique_ops))]

    ops = sorted(list(zip(unique_ops, counts, contrib)), key=lambda x: x[2], reverse=True)

    for i, (op, count, contrib) in enumerate(ops[:5]):
        ld = db[op, arch_ext]
        cols = ' & '.join([
            f'{ni}',
            op_short_str(op),
            f'{db[op, arch_ext].util * 100:.2f}\\%',
            f'{db_notp[op, arch_ext].util * 100:.2f}\\%',
            f'{nv[op, None].util * 100:.2f}\\%',
            ' '.join(map(process_tag, tags[ti])),
        ])
        if mask[ti]:
            print(cols, '\\\\', f'% {sens}')
            ni += 1

        ti += 1

print("""
\\begin{tabular}{llrrrl}
\\hline
 & \\multicolumn{1}{c}{\\textbf{Op}} & \\multicolumn{2}{c}{\\textbf{UPCYCLE +TP, -TP}} & \\multicolumn{1}{c}{\\textbf{A100}} & \\multicolumn{1}{c}{\\textbf{Comments}} \\\\ \\hline""")

for appname in appnames:
    for mode in ['infer', 'train']:
        for large in [True]:
            batch = {
                ('infer', False): 'online',
                ('infer', True): 'offline',
                ('train', False): 'small',
                ('train', True): 'large',
            }[(mode, large)]
            app = apps[f'{appname}-{mode}-{batch}']

            if mode == 'train': app = U.apps.post_process_train_app(app)

            # print(f'{appname}-{mode}-{batch}')
            # print()
            if mode == 'infer':
                print(f' & \\multicolumn{{5}}{{c}}{{\\textbf{{{appname}}}}} \\\\ \\hline')

            analyze_app(db, app)
            if mode == 'train': print('\\hline')




print("\\end{tabular}")

